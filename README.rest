.. vim: ft=rst sts=2 sw=2 tw=70
.. default-role:: literal

======================================================================
                             studio_napi
======================================================================
----------------------------------------------------------------------
              SUSE Studio API client library for Node.js
----------------------------------------------------------------------

:Author: Roman Neuhauser
:Contact: rneuhauser@suse.cz
:Copyright: This document is in the public domain.

.. This file is marked up using reStructuredText.
   Lines beginning with ".." are reST directives.
   "foo_" or "`foo bar`_" is a link, defined at ".. _foo" or
   ".. _foo bar".
   "::" introduces a literal block (usually some form of code).
   "`foo`" is some kind of identifier.
   Suspicious backslashes in the text ("`std::string`\s") are required
   for reST to recognize the preceding character as syntax.

.. contents::

.. important links:

.. _studio_napi: https://github.com/roman-neuhauser/studio_napi
.. _SUSE Studio: http://susestudio.com/
.. _Node.js: http://nodejs.org/
.. _NPM: http://npmjs.org/
.. _NPM Registry: http://search.npmjs.org/

Overview
========

studio_napi_ is a client library for the `SUSE Studio`_ HTTP API
targetting `Node.js`_.  Two interfaces are exposed, a low-level
and a high-level one.  Both interfaces implement both the admin
and user sides of the API (v2 at the moment).

Status
======

`studio_napi` is in development.  The low-level interface is
implemented to a large extent, the last remaining bits are being
fleshed out; the high-level interface has been designed and we
started the implementation.

POJO Description Language
=========================

Inputs and outputs are described using a would-be object structure
description language.

Common parts of the vocabulary: ::

  Decimal       =o  /^\d+\.\d+/
  Percent       =o  /^\d+%/
  Id            =o  Nonnegative Integer
  Count         =o  Nonnegative Integer
  Seconds       =o  Nonnegative Integer
  IP            =o  (v) ->
    r = v.match /^(\d{1,3})\.(\d{1,3})\.(\d{1,3}).(\d{1,3})$/
    Fail unless r and r[4]
    for b in r[1..]
      Fail if b < 1 or b > 254
  Hostname      =o  /^[a-z]+[-a-z]*[a-z](:?\.[a-z]+[-a-z]*[a-z])*$/
  Host          =o  OneOf IP, Hostname
  Port          =o  OneOf Interval 1, 65536 + 1
  HostPort      =o  "#{Host}:#{Port}"
  Envname       =o  OneOf 'development', 'production', 'testing'
  Hex32         =o  /^[a-f0-9]{32}$/i
  Hex40         =o  /^[a-f0-9]{40}$/i
  Timestamp     =o  /^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\dZ$/
  EmailAddress  =o  /^.+@.+$/
  String        =o  /.*/
  URL           =o  /^https?:\/\/.+$/
  Version       =o  /^\d+\.\d+\.\d+$/
  MBytes        =o  Nonnegative Integer
  LocalPath     =o  /^(?:\/[^/]+)+/
  TrueFalse     =o  OneOf 'true', 'false'
  Username      =o  /^[-\w]+$/
  Groupname     =o  /^[-\w]+$/
  Basename      =o  /^[^/]+$/
  RunLevel      =o  OneOf [1..5]
  OnOff         =o  TypeOf Boolean
  YesNo         =o  TypeOf Boolean
  PackageName   =o  String
  RepositoryName =o String
  SWPatternName =o  String
  LVMGroupName  =o  String
  Locale        =o  String
  BaseSystem    =o  String
  ImageType     =o  OneOf \
    'azure dasd ec2 iso net oem oemiso ovf vhd vmx xen zfcp'.split ' '



Low-level Interface
===================

This is a fairly straightforward async functional interface
using POJOs in place of XML and streams for binary data.

`napilo.session`
++++++++++++++++

`studio_napi/lib/lo` exposes a `session` function which takes
an object specifying the Studio server to connect to, the desired
API side (admin or user), and credentials (see your Studio profile).

**Synopsis** ::

  napilo = require 'studio_napi/lib/lo'

  napilo.session (admin|user):
    url: <url>
    user: <username>
    key: <API key>

`napilo.session` Examples
~~~~~~~~~~~~~~~~~~~~~~~~~

Admin API: ::

  napilo = require 'studio_napi/lib/lo'

  anapi = napilo.session admin:
    url: 'http://susestudio.com/api/v2/admin'
    user: 'rneuhauser'
    key: '69sNafUbAR'

User API: ::

  napilo = require 'studio_napi/lib/lo'

  unapi = napilo.session user:
    url: 'http://susestudio.com/api/v2/user'
    user: 'rneuhauser'
    key: '69sNafUbAR'


`DELETE`, `GET`, `POST`, `PUT`
++++++++++++++++++++++++++++++

To support a slightly more DSLish code, `studio_napi` publishes global
functions corresponding to used HTTP methods; see `unapi, anapi
Examples`_.

**Synopsis** ::

  DELETE = (apimethod[, params], done) ->
  GET    = (apimethod[, params], done) ->
  POST   = (apimethod[, params], done) ->
  PUT    = (apimethod[, params], done) ->


`unapi`, `anapi`
++++++++++++++++

The value returned from `napilo.session` is a function which takes
3 or 4 arguments:

**Synopsis** ::

  anapi = (httpmethod, apimethod[, params], done) ->
  unapi = (httpmethod, apimethod[, params], done) ->

HTTP method
  One of `DELETE`, `GET`, `POST`, `PUT`.
apimethod
  Shortened API method path (without the leading `/api/v2`)
  substrings matching Perl-compatible regular expression /:(\w+)\b/
  are replaced by params[$1].
params
  Optionally, an object of API parameters.  Params not used in
  `apimethod` substitutions comprise the query string.
done: `(error, response) -> ...`
  If `error` is falsy, `reponse` contains a POJO derived from the XML
  response received from Studio server.

`unapi`, `anapi` Examples
~~~~~~~~~~~~~~~~~~~~~~~~~

All examples assume the following code: ::

  assert = require 'assert'
  expect = (require 'chai').expect
  napilo = require 'studio_napi/lib/lo'

  anapi = napilo.session admin:
    url: 'http://susestudio.com/api/v2/admin'
    user: 'rneuhauser'
    key: '69sNafUbAR'

  unapi = napilo.session user:
    url: 'http://susestudio.com/api/v2/user'
    user: 'rneuhauser'
    key: '69sNafUbAR'

A simple GET request: ::

  # GET /api/v2/admin/about

  anapi GET '/about', (e, r) ->

    assert.ifError e, "/about failed: #{e}"

    for p in 'server_name environment git_revision'.split ' '
      (expect r).to.have.property p

URL path substitutions: ::

  # GET /api/v2/user/appliances/42

  unapi GET '/appliances/:app', {app: 42}, (e, r) ->

    assert.ifError e, "/appliances/:app failed: #{e}"

    (expect r).to.have.property 'appliance'

Parameters which are not substituted into `apimethod` form the query
string: ::

  # GET /api/v2/admin/health_check?runner_threshold=75

  anapi GET '/health_check', runner_threshold: 75, (e, r) ->

    assert.ifError e, "/health_check failed: #{e}"

    for p in 'state kiwi_runners testdrive_runners disks'.split ' '
      (expect r).to.have.property p


.. note:: FIXME

  POST form uploads, file uploads, request bodies are neither
  described nor implemented ATM.


`unapi`, `anapi` Endpoints
++++++++++++++++++++++++++

An endpoint is a combination of:
  - HTTP method
  - URL template
  - parameters

`anapi GET /about`
~~~~~~~~~~~~~~~~~~

Result ::

  about:
    server_name: HostPort
    environment: Envname
    git_revision: Hex40

`anapi GET /active_users`
~~~~~~~~~~~~~~~~~~~~~~~~~

Result ::

  active_users:
    since: Seconds
    users: ArrayOf Id

`anapi GET /health_check`
~~~~~~~~~~~~~~~~~~~~~~~~~

Result ::

  Runner =o \
    id: Id
    address: HostPort
    status: OneOf 'auto_disabled', 'disabled', 'pinged', 'registered', 'unreachable'
    last_pinged: Timestamp
    slots: Count
    used_slots: Count
    load: Decimal

  Disk =o \
    path: LocalPath
    used: Percent
    available: Bytes

  ServiceState =o OneOf 'ok', 'error'

  health_check:
    state: ServiceState
    mysql: ServiceState
    thoth: ServiceState
    rmds: ServiceState
    kiwi_runners: ArrayOf Runner
    testdrive_runners: ArrayOf Runner
    disks: ArrayOf Disk

`anapi GET /job_history`
~~~~~~~~~~~~~~~~~~~~~~~~

Result ::

  job_history:
    since: Seconds
    builds:
      succeeded: Count
      failed: Count
      successrate: Count
    testdrives: Count

`anapi GET /running_jobs`
~~~~~~~~~~~~~~~~~~~~~~~~~

Result ::

  running_jobs:
    builds: ArrayOf Id
    testdrives: ArrayOf Id

`anapi GET /summary`
~~~~~~~~~~~~~~~~~~~~

Result ::

  Disk =o \
    filesystem: LocalPath
    total: Bytes
    used: Bytes
    used_percentage: Percent
    available: Bytes
    mount_point: LocalPath

  summary:
    since: Seconds
    last_bug_status_refresh_time: OneOf undefined, Timestamp
    unassigned_failures_count: Count
    builds:
      succeeded: Count
      failed: Count
      errored: Count
      successrate: Count
    testdrives: Count
    active_users: ArrayOf Id
    disks: ArrayOf Disk
    bugs: ArrayOf Id

`unapi GET /account`
~~~~~~~~~~~~~~~~~~~~

Result ::

  DiskSize      =o  /^\d+(?:\.\d+)[KMGTPYZ]B$/

  Account =o account:
    username: Username
    displayname: String
    email: EmailAddress
    created_at: Timestamp
    openid_urls: ArrayOf URL
    disk_quota:
      available: DiskSize
      used: Percent

`unapi GET /api_version`
~~~~~~~~~~~~~~~~~~~~~~~~

Result ::

  version: /^\d+(?:\.\d+)+$/

`unapi GET /appliances`
~~~~~~~~~~~~~~~~~~~~~~~

Result ::

  appliances: ArrayOf Appliance

`unapi GET /appliances/:app`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Result ::

  Build =o \
    id: Id
    version: Version
    image_type: ImageType
    image_size: MBytes
    compressed_image_size: MBytes
    download_url: URL

  Appliance =o \
    id: Id
    name: String
    last_edited: Timestamp
    edit_url: URL
    icon_url: URL
    basesystem: BaseSystem
    parent:
      id: Id
      name: String
    builds: ArrayOf Build

  apliance: Appliance

`unapi GET /appliances/:app/configuration`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Result ::

  Autostart =o \
    command: String
    description: String
    enabled: TrueFalse
    user: Username

  DbUser =o \
    username: Username
    password: String
    database_list: ListOf String, /,\s*/

  Database =o \
    type: OneOf 'mysql', 'pgsql'
    users: ArrayOf DbUser

  LVMVolume =o \
    size: MBytes
    path: LocalPath

  Script =o \
    enabled: TrueFalse
    script: Text

  User =o \
    name: Username
    password: String
    group: Groupname
    shell: LocalPath
    homedir: LocalPath

  configuration:
    id: Id
    name: String
    description: Text
    website: URL
    tags: ArrayOf Tag
    locale:
      keyboard_layout: String
      language: Locale
      timezone:
        location: Timezone
    network:
      type: OneOf 'dhcp', 'manual'
      hostname: Hostname
      ip: IP
      netmask: IP
      route: IP
      nameservers: ListOf IP, /,\s*/
    firewall:
      enabled: TrueFalse
      open_ports: ArrayOf 'ssh', 'http'
    users: ArrayOf User
    eulas: ArrayOf Text
    databases: ArrayOf Database
    autostarts: ArrayOf Autostart
    settings:
      memory_size: MBytes
      disk_size: GBytes
      swap_size: MBytes
      pae_enabled: TrueFalse
      xen_host_mode_enabled: TrueFalse
      cdrom_enabled: TrueFalse
      webyast_enabled: TrueFalse
      public_clonable: TrueFalse
      runlevel: RunLevel
      automatic_login: Username
    lvm:
      enabled: TrueFalse
      volume_group: LVMGroupName
      volumes: ArrayOf LVMVolume
    scripts:
      build: Script
      boot: Script
      autoyast: Script

`unapi GET /appliances/:app/gpg_keys`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Result ::

  GPGKey =o \
    id: Id
    name: String
    target: String
    key: Text

  gpg_keys: ArrayOf GPGKey

`unapi GET /appliances/:app/gpg_key/:key`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Result ::

  gpg_key: GPGKey

`unapi GET /appliances/:app/sharing`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Result ::

  appliance:
    id: Id
    read_users: ArrayOf Username


`unapi GET /appliances/:app/software`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Result ::

  software:
    appliance_id: Id
    patterns: ArrayOf SoftwarePattern
    packages: ArrayOf Package

`unapi GET /appliances/:app/status`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Result ::

  Issue =o \
    type: OneOf 'error', ...
    text: String
    solution:
      type: OneOf 'install', ...
      package: PackageName

  status:
    state: OneOf 'error', 'ok'
    issues: ArrayOf Issue

`unapi GET /builds`
~~~~~~~~~~~~~~~~~~~

Result ::

  Build =o \
    id: Id
    version: Version
    state: OneOf 'finished', ...
    expired: TrueFalse
    image_type: ImageType
    checksum:
      md5: Hex32
      sha1: Hex40
    size: MBytes
    compressed_image_size: MBytes

  builds: ArrayOf Build

`unapi GET /builds/:bld`
~~~~~~~~~~~~~~~~~~~~~~~~

Result ::

  build: Build

`unapi GET /files`
~~~~~~~~~~~~~~~~~~

Result ::

  File =o \
    id: Id
    filename: Basename
    path: LocalPath
    owner: Username
    group: Groupname
    permissions: /^[0-7]{3}$/
    enabled: TrueFalse
    download_url: URL

  file: ArrayOf File

`unapi GET /files/:file`
~~~~~~~~~~~~~~~~~~~~~~~~

Result ::

  file: File

`unapi GET /repositories`
~~~~~~~~~~~~~~~~~~~~~~~~~

Result ::

  Repository =o \
    id: Id
    name: String
    type: OneOf 'rpm-md', ...
    base_system: BaseSystem
    base_url: URL
    matches:
      repository_name: String
      repository_base_url: URL

  repositories: ArrayOf Repository

`unapi GET /repositories/:repo`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Result ::

  repository: Repository

`unapi GET /rpms`
~~~~~~~~~~~~~~~~~

Result ::

  RPM =o \
    id: Id
    filename: Basename
    size: Bytes
    archive: TrueFalse

  rpms:
    base_system: BaseSystem
    rpms: ArrayOf RPM

`unapi GET /rpms/:rpm`
~~~~~~~~~~~~~~~~~~~~~~

Result ::

  rpm:
    id: Id
    filename: Basename
    size: Bytes
    archive: TrueFalse
    base_system: BaseSystem

`unapi GET /running_builds`
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Result ::

  RunningBuild =o \
    id: Id
    state: OneOf 'running', ...
    percent: OneOf [0..100]
    time_elapsed: Seconds
    message: String

  running_builds: ArrayOf RunningBuild

`unapi GET /running_builds/:bld`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Result ::

  running_build: RunningBuild

`unapi GET /testdrives`
~~~~~~~~~~~~~~~~~~~~~~~

Result ::

  TestDrive =o \
    id: Id
    state: OneOf 'running', ...
    build_id: Id

  testdrives: ArrayOf TestDrive

`unapi POST /testdrives`
~~~~~~~~~~~~~~~~~~~~~~~~

Result ::

  testdrive:
    id: Id
    state: OneOf 'new', ...
    build_id: Id
    url: URL
    server:
      vnc:
        host: Hostname
        port: Port
        password: String

High-level Interface
====================

`napihi.session`
++++++++++++++++

`studio_napi/lib/hi` exposes a `session` function which takes
an object specifying the Studio server to connect to, the desired
API side (admin or user), and credentials (see your Studio profile)..

**Synopsis** ::

  napihi = require 'studio_napi/lib/hi'

  napihi.session (admin|user):
    url: <url>
    user: <username>
    key: <API key>

`napihi.session` Examples
~~~~~~~~~~~~~~~~~~~~~~~~~

Admin API: ::

  napihi = require 'studio_napi/lib/hi'

  admin = napihi.session admin:
    url: 'http://susestudio.com/api/v2/admin'
    user: 'rneuhauser'
    key: '69sNafUbAR'

User API: ::

  napihi = require 'studio_napi/lib/hi'

  user = napihi.session user:
    url: 'http://susestudio.com/api/v2/user'
    user: 'rneuhauser'
    key: '69sNafUbAR'

`admin`
+++++++

The admin side is a simple object with methods corresponding 1:1
to the low-level admin endpoints:

`admin` Examples
~~~~~~~~~~~~~~~~

::

  napihi = require 'studio_napi/lib/hi'

  admin = napihi.session admin:
    url: 'http://susestudio.com/api/v2/admin'
    user: 'rneuhauser'
    key: '69sNafUbAR'

  admin.about (e, r) ->

    assert.ifError e, "/about failed: #{e}"

    for p in 'server_name environment git_revision'.split ' '
      (expect r).to.have.property p

  admin.health_check, runner_threshold: 75, (e, r) ->

    assert.ifError e, "/health_check failed: #{e}"

    for p in 'state kiwi_runners testdrive_runners disks'.split ' '
      (expect r).to.have.property p


`user`
++++++

`user.create appliance`
~~~~~~~~~~~~~~~~~~~~~~~

Input ::

  appliance:
    named: String
    based_on: BaseSystem

`app.add package`
~~~~~~~~~~~~~~~~~

Input ::

  package:
    named: PackageName
    from: RepositoryName
    version: Version

`app.add pattern`
~~~~~~~~~~~~~~~~~

Input ::

  pattern:
    named: SWPatternName
    from: RepositoryName

`app.add user`
~~~~~~~~~~~~~~

Input ::

  user:
    named: Username
    id: Id
    member_of: ArrayOf Groupname
    identified_by:
      password: String

`app.configure LVM`
~~~~~~~~~~~~~~~~~~~

Input ::

  LVM:
    enabled: YesNo
    group: LVMGroupName
    comprising: Map LocalPath, DiskSize

`app.configure PostgreSQL`
~~~~~~~~~~~~~~~~~~~~~~~~~~

Input ::

  PostgreSQL: ArrayOf DbUser

`app.configure network`
~~~~~~~~~~~~~~~~~~~~~~~

Input ::

  network:
    hostname: Hostname
    address: IP
    netmask: IP
    gateway: IP
    resolvers: ListOf IP, '/,\s*/


`app.configure RAM`
~~~~~~~~~~~~~~~~~~~

Input ::

  RAM: DiskSize

`app.configure disk`
~~~~~~~~~~~~~~~~~~~~

Input ::

  disk: DiskSize

`app.configure swap`
~~~~~~~~~~~~~~~~~~~~

Input ::

  swap: DiskSize

`app.select locale`
~~~~~~~~~~~~~~~~~~~

Input ::

  locale:
    language: String
    keyboard: String

`app.select runlevel`
~~~~~~~~~~~~~~~~~~~~~

Input ::

  runlevel: RunLevel

`app.toggle PostgreSQL`
~~~~~~~~~~~~~~~~~~~~~~~

Input ::

  PostgreSQL: OnOff

`app.toggle MySQL`
~~~~~~~~~~~~~~~~~~

Input ::

  MySQL: OnOff

`app.toggle PAE`
~~~~~~~~~~~~~~~~

Input ::

  PAE: OnOff

`app.toggle Xen_DOM0`
~~~~~~~~~~~~~~~~~~~~~

Input ::

  Xen_DOM0: OnOff


`user` Examples
~~~~~~~~~~~~~~~~

The user side is an internal DSL.

::

  user = studio.session user:
    url: 'http://susestudio.com/api/v2/user'
    user: 'rneuhauser'
    key: '69sNafUbAR'

  app = user.create appliance:
    named: 'my system'
    based_on: 'SLES11 SP2'

  app.configure LVM:
    enabled: yes
    group: 'mighty-lvm'
    comprising:
      "/var": "800G"
      "/fuvar": "12T"

  app.configure PostgreSQL: [
    { user: 'db_user', password: 'secret', databases: 'foo bar' }
    { user: 'db_admin', password: 'top-secret' }
  ]

  app.toggle PostgreSQL: on
  app.toggle MySQL: off

  app.select runlevel: 3

  app.add package:
    named: 'djbdns'
    from: 'My Repository'
    version: '1.2.3'

  app.add pattern:
    named: 'development'
    from: 'His Repository'

  app.add user:
    named: 'toor'
    id: 1000
    member_of: 'wheel'
    identified_by:
      password: 'secret'

  app.select locale:
    language: 'POSIX'
    keyboard: 'English (US)'

  app.configure network:
    hostname: 'thisbox'
    address: '1.2.3.4'
    netmask: '255.255.0.0'
    gateway: '1.2.1.1'
    resolvers: '1.3.1.53 1.3.2.53'

  app.configure RAM: '1G'
  app.configure disk: '3T'
  app.configure swap: '8G'

  app.toggle PAE: on
  app.toggle Xen_DOM0: off

  app.commit()


Prerequisities
==============

* `Node.js`_ 0.6.x or higher
* NPM_ (any version appropriate for your version of Node.js)
* several packages installable with `npm` (see package.json)


Installation
============

`studio_napi` will appear in the `NPM Registry`_ once it's ready.


Hacking
=======

If you want to hack on `studio_napi`: ::

  git clone https://github.com/roman-neuhauser/studio_napi.git
  cd studio_napi
  npm install
  npm test # or: make check
  # happy hacking

The `npm install` above downloads and installs studio_napi's
dependencies locally (in `./node_modules/`).

