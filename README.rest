.. vim: ft=rst sts=2 sw=2 tw=70
.. default-role:: literal

======================================================================
                             studio_napi
======================================================================
----------------------------------------------------------------------
              SUSE Studio API client library for Node.js
----------------------------------------------------------------------

:Author: Roman Neuhauser
:Contact: rneuhauser@suse.cz
:Copyright: This document is in the public domain.

.. This file is marked up using reStructuredText.
   Lines beginning with ".." are reST directives.
   "foo_" or "`foo bar`_" is a link, defined at ".. _foo" or
   ".. _foo bar".
   "::" introduces a literal block (usually some form of code).
   "`foo`" is some kind of identifier.
   Suspicious backslashes in the text ("`std::string`\s") are required
   for reST to recognize the preceding character as syntax.

.. important links:

.. _studio_napi: https://github.com/roman-neuhauser/studio_napi
.. _SUSE Studio: http://susestudio.com/
.. _Node.js: http://nodejs.org/
.. _NPM: http://npmjs.org/
.. _NPM Registry: http://search.npmjs.org/

Overview
========

studio_napi_ is a client library for the `SUSE Studio`_ HTTP API
targetting `Node.js`_.  Two interfaces are exposed, a low-level
and a high-level one.  Both interfaces implement both the admin
and user sides of the API (v2 at the moment).

Status
======

`studio_napi` is in development.  The low-level interface is
implemented to a large extent, the last remaining bits are being
fleshed out; the high-level interface has been designed and we
started the implementation.


Low-level Interface
===================

This is a fairly straightforward async functional interface
using POJOs in place of XML and streams for binary data.

`studio_napi/lib/lo` exposes a `session` function which takes
an object specifying the Studio server to connect to, the desired
API side (admin or user), and credentials.

::

  napilo = require 'studio_napi/lib/lo'

  anapi = napilo.session admin:
    url: 'http://susestudio.com/api/v2/admin'
    user: 'rneuhauser'
    key: '69sNafUbAR'

::

  napilo = require 'studio_napi/lib/lo'

  unapi = napilo.session user:
    url: 'http://susestudio.com/api/v2/user'
    user: 'rneuhauser'
    key: '69sNafUbAR'

The value returned is a function which takes 3 or 4 arguments:

::

  httpmethod, apimethod, [params,] done

HTTP method
  one of `DELETE`, `GET`, `POST`, `PUT`.
apimethod
  shortened API method path (without the leading `/api/v2`)
  substrings matching Perl-compatible regular expression /:(\w+)\b/
  are replaced by params[$1].
params
  optionally, an object of API parameters.  params not used in
  `apimethod` substitutions comprise the query string.
done: `(error, response) -> ...`
  if `error` is falsy, `reponse` contains a POJO derived from the XML
  response received from Studio server.

To support a slightly more DSLish code, `studio_napi` publishes global
functions corresponding to used HTTP methods; see example.

Examples
++++++++

All examples assume the following code: ::

  assert = require 'assert'
  expect = (require 'chai').expect
  napilo = require 'studio_napi/lib/lo'

  anapi = napilo.session admin:
    url: 'http://susestudio.com/api/v2/admin'
    user: 'rneuhauser'
    key: '69sNafUbAR'

  unapi = napilo.session user:
    url: 'http://susestudio.com/api/v2/user'
    user: 'rneuhauser'
    key: '69sNafUbAR'

A simple GET request: ::

  # GET /api/v2/admin/about

  anapi GET '/about', (e, r) ->

    assert.ifError e, "/about failed: #{e}"

    for p in 'server_name environment git_revision'.split ' '
      (expect r).to.have.property p

URL path substitutions: ::

  # GET /api/v2/user/appliances/42

  unapi GET '/appliances/:app', {app: 42}, (e, r) ->

    assert.ifError e, "/appliances/:app failed: #{e}"

    (expect r).to.have.property 'appliance'

Parameters which are not substituted into `apimethod` form the query
string: ::

  # GET /api/v2/admin/health_check?runner_threshold=75

  anapi GET '/health_check', runner_threshold: 75, (e, r) ->

    assert.ifError e, "/health_check failed: #{e}"

    for p in 'state kiwi_runners testdrive_runners disks'.split ' '
      (expect r).to.have.property p


.. note:: FIXME

  POST form uploads, file uploads, request bodies are neither
  described nor implemented ATM.

High-level Interface
====================

`studio_napi/lib/hi` exposes a `session` function which takes
an object specifying the Studio server to connect to, the desired
API side (admin or user), and credentials.

::

  napihi = require 'studio_napi/lib/hi'

  admin = napihi.session admin:
    url: 'http://susestudio.com/api/v2/admin'
    user: 'rneuhauser'
    key: '69sNafUbAR'

::

  napihi = require 'studio_napi/lib/hi'

  user = napihi.session user:
    url: 'http://susestudio.com/api/v2/user'
    user: 'rneuhauser'
    key: '69sNafUbAR'

Admin
+++++

The admin side is a simple object with methods corresponding 1:1
to the low-level admin endpoints:

Example: ::

  napihi = require 'studio_napi/lib/hi'

  admin = napihi.session admin:
    url: 'http://susestudio.com/api/v2/admin'
    user: 'rneuhauser'
    key: '69sNafUbAR'

  admin.about (e, r) ->

    assert.ifError e, "/about failed: #{e}"

    for p in 'server_name environment git_revision'.split ' '
      (expect r).to.have.property p

  admin.health_check, runner_threshold: 75, (e, r) ->

    assert.ifError e, "/health_check failed: #{e}"

    for p in 'state kiwi_runners testdrive_runners disks'.split ' '
      (expect r).to.have.property p


User
++++

The user side is an internal DSL.

Example: ::

  user = studio.session user:
    url: 'http://susestudio.com/api/v2/user'
    user: 'rneuhauser'
    key: '69sNafUbAR'

  app = user.create appliance:
    named: 'my system'
    based_on: 'SLES11 SP2'

  app.configure LVM:
    enabled: yes
    group: 'mighty-lvm'
    comprising:
      "/var": "800G"
      "/fuvar": "12T"

  app.configure PostgreSQL: [
    { user: 'db_user', password: 'secret', databases: 'foo bar' }
    { user: 'db_admin', password: 'top-secret' }
  ]

  app.toggle PostgreSQL: on
  app.toggle MySQL: off

  app.select runlevel: 3

  app.add package:
    named: 'djbdns'
    from: 'My Repository'
    version: '1.2.3'

  app.add pattern:
    named: 'development'
    from: 'His Repository'

  app.add user:
    named: 'toor'
    id: 1000
    member_of: 'wheel'
    identified_by:
      password: 'secret'

  app.select locale:
    language: 'POSIX'
    keyboard: 'English (US)'

  app.configure network:
    hostname: 'thisbox'
    address: '1.2.3.4'
    netmask: '255.255.0.0'
    gateway: '1.2.1.1'
    resolvers: '1.3.1.53 1.3.2.53'

  app.configure RAM: '1G'
  app.configure disk: '3T'
  app.configure swap: '8G'

  app.toggle PAE: on
  app.toggle Xen_DOM0: off

  app.commit()


Prerequisities
==============

* `Node.js`_ 0.6.x or higher
* NPM_ (any version appropriate for your version of Node.js)
* several packages installable with `npm` (see package.json)


Installation
============

`studio_napi` will appear in the `NPM Registry`_ once it's ready.


Hacking
=======

If you want to hack on `studio_napi`: ::

  git clone https://github.com/roman-neuhauser/studio_napi.git
  cd studio_napi
  npm install
  npm test # or: make check
  # happy hacking

The `npm install` above downloads and installs studio_napi's
dependencies locally (in `./node_modules/`).

